/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from "react";
import { Vector3, BufferGeometry, CatmullRomCurve3 } from "three";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useEffect } from "react/cjs/react.development";
import { useLoader, useThree } from "@react-three/fiber";
import anime from "animejs/lib/anime.es";
import { FrontSide, TextureLoader } from "three";

import useStore from "../store";
import { seekGltfAnimation } from "../helpers/animation";
import createSpiralPathFromCoordinateWithRadius from "./world/createPath";

export default function Model({ ...props }) {
  const { camera } = useThree();

  const group = useRef();
  const { nodes, animations } = useGLTF(
    process.env.PUBLIC_URL + "/testOnlyPlane.glb"
  );
  const { actions } = useAnimations(animations, group);

  const front = useLoader(TextureLoader, process.env.PUBLIC_URL + "/front.jpg");
  front.flipY = false;
  const back = useLoader(TextureLoader, process.env.PUBLIC_URL + "/back.jpg");
  back.flipY = false;

  const up = new Vector3(0, 0, -1);
  const axis = new Vector3();

  const planeFoldingProgressChecker = useRef(0);
  const planeToClockProgressChecker = useRef(0);

  const lineRef = useRef();

  lineRef.current && lineRef.current.computeLineDistances();

  /** Line */
  const [points] = useState(() => {
    return [
      new Vector3(15, -1.09, 682),
      new Vector3(10, 2, 640.0),
      new Vector3(10, -1, 600.0),
      new Vector3(40, -5, 580),
      new Vector3(100, 12, 550),
      ...createSpiralPathFromCoordinateWithRadius({
        coordinate: [-200, 15, 490],
        radius: 15,
        spirals: 3,
        heightDivider: 3,
      }).points,
      new Vector3(-185, 0, 505),
      new Vector3(-100, 2, 505),
      new Vector3(50, 0, 500),
      ...createSpiralPathFromCoordinateWithRadius({
        coordinate: [200, 4, 430],
        direction: 1,
        radius: 16,
        spirals: 3,
        heightDivider: 3,
      }).points,
      new Vector3(100, 4, 400),
      new Vector3(50, -4, 380),
      new Vector3(0, 4, 380),
      new Vector3(0, 0, 350),
      new Vector3(0, 10, 300),
      new Vector3(0, 20, 270),
      new Vector3(0, 30, 220),
      new Vector3(0, 40, 200),
      new Vector3(0, 40, 200),
      new Vector3(0, 40, 200),
      new Vector3(0, 30, 200),
      new Vector3(0, 30, 200),
      new Vector3(0, 30, 210),
      new Vector3(0, 30, 200),
      new Vector3(0, 30, 200),
      new Vector3(0, 30, 200),
      new Vector3(0, 90, 200),
      new Vector3(0, 90, 170),
      new Vector3(0, 90, 170),
      new Vector3(0, 90, 100),
      new Vector3(0, 130, 100),
      new Vector3(0, 130, 100),
      new Vector3(0, 130, 100),
      new Vector3(0, 180, 50),
      new Vector3(0, 180, 50),
      new Vector3(0, 180, 150),
      new Vector3(0, 180, 150),
      new Vector3(0, 180, 150),
      new Vector3(0, 1800, 100),
      new Vector3(0, 1800, 100),
    ];
  });

  const [line] = useState(() => {
    const c = new CatmullRomCurve3(points);
    c.tension = 1;
    c.arcLengthDivisions = 20000;
    c.curveType = "catmullrom";

    return c;
  });

  const [lineGeometry] = useState(() =>
    new BufferGeometry().setFromPoints(line.getSpacedPoints(20000))
  );

  function movePlane({ fraction, isBackward, moveCamera }) {
    if (!group.current) return;

    //move
    const point = line.getPoint(fraction);
    const { x, y, z } = point;
    group.current.position.set(...[x, y, z]);

    //rotate
    if (isBackward) {
      up.z = 1;
    } else {
      up.z = -1;
    }
    const tangent = line.getTangent(fraction);
    axis.crossVectors(up, tangent).normalize();
    const angle = Math.acos(up.dot(tangent));
    group.current.quaternion.setFromAxisAngle(axis, angle);
    //WORKS:
    group.current.rotation.x = -Math.PI / 2;

    if (moveCamera) {
      camera.position.set(...[x, y + 3, z + 20]);
    }
  }

  useEffect(() => {
    if (!group.current) return;

    const unsubcribeFromMutualAnimationListener = useStore.subscribe(
      (state) => state.initialAnimation,
      ({ planeAndSheetReverseOpacitiesProgress }) => {
        if (planeAndSheetReverseOpacitiesProgress > 95) {
          group.current.visible = true;
        } else {
          group.current.visible = false;
        }
      }
    );

    const planeToInitialTrajectoryPoint = anime({
      targets: [group.current.position, group.current.quaternion],
      //todo: add these values
      duration: 500,
      autoplay: false,
    });

    const { fold } = actions;
    const unsubcribeFromPlaneAnimationListener = useStore.subscribe(
      (state) => state.plane,
      ({
        planeFoldingProgress,
        lastChanged,
        planeToInitialTrajectoryPointProgress,
        planeToClockProgress,
      }) => {
        switch (lastChanged) {
          case "planeFoldingProgress":
            seekGltfAnimation(
              fold,
              planeFoldingProgress,
              planeFoldingProgressChecker,
              0,
              10000
            );
            break;
          case "planeToInitialTrajectoryPointProgress":
            planeToInitialTrajectoryPoint.seek(
              planeToInitialTrajectoryPointProgress
            );
            break;
          case "planeToClockProgress":
            //NO NEED TO SEEK, use the porgress value here for updates.

            // planeToClockMove.seek(planeToClockProgress);
            // planeToClockRotate.seek(planeToClockProgress);

            if (planeToClockProgressChecker.current > planeToClockProgress) {
              //going backwards
              movePlane({
                fraction: planeToClockProgress / 2000,
                isBackward: true,
                moveCamera: true,
              });
            } else {
              //going forward or staying in place
              movePlane({
                fraction: planeToClockProgress / 2000,
                isBackward: false,
                moveCamera: true,
              });
            }
            planeToClockProgressChecker.current = planeToClockProgress / 2000;
            break;
          default:
            break;
        }
      }
    );

    return () => {
      unsubcribeFromMutualAnimationListener();
      unsubcribeFromPlaneAnimationListener();
    };
  }, [group.current]);

  return (
    <>
      <line ref={lineRef} geometry={lineGeometry}>
        <lineDashedMaterial
          emissive="red"
          emissiveIntensity={10}
          scale={1}
          dashSize={0.5}
          gapSize={0.5}
          color="red"
        />
      </line>
      <group
        //it's a very very very absolutley bad idea to change the position, only if you match it with the seet position, as they swap visibilies. incopetent blender trick just to save some time, please don't be judge too much :/
        position={[15, -1.09, 682]}
        // rotation={[0, 0, 0]}
        ref={group}
        {...props}
        visible={false}
        dispose={null}
      >
        <mesh
          name="material"
          geometry={nodes.material.geometry}
          material={nodes.material.material}
          morphTargetDictionary={nodes.material.morphTargetDictionary}
          morphTargetInfluences={nodes.material.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.material.material}
            map={back}
            roughness={1}
            metalness={0.4}
            transparent={true}
            depthTest={true}
            alphaTest={0.5}
          />
        </mesh>
        <mesh
          name="material_1"
          geometry={nodes.material_1.geometry}
          material={nodes.material_1.material}
          morphTargetDictionary={nodes.material_1.morphTargetDictionary}
          morphTargetInfluences={nodes.material_1.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.material_1.material}
            map={front}
            roughness={1}
            metalness={0.4}
            transparent={true}
            depthTest={true}
            alphaTest={0.5}
          />
        </mesh>
        <mesh
          name="material_2"
          geometry={nodes.material_2.geometry}
          material={nodes.material_2.material}
          morphTargetDictionary={nodes.material_2.morphTargetDictionary}
          morphTargetInfluences={nodes.material_2.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.material_2.material}
            color="#fff"
            emissive="#fff"
          />
        </mesh>
      </group>
    </>
  );
}

useGLTF.preload(process.env.PUBLIC_URL + "/testOnlyPlane.glb");
