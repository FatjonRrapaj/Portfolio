/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import useStore from "../store";
import anime from "animejs/lib/anime.es";

import { Time, Patience, Android, IOS, ReactJS } from "./paragraphs";

import { objectPositionsInSpace } from "./constants";
import { LoopRepeat, LoopOnce } from "three";

//https://discourse.threejs.org/t/playing-an-animation-changes-behaviour-of-next-animation/14928/7

export default function Model({ ...props }) {
  const { camera } = useThree();

  //cube refs
  const mainContainer = useRef();
  const secondaryContainer = useRef();

  //material refs
  const mainCubeMaterial = useRef();
  const mainCubeFaceMaterial = useRef();
  const cube1Material = useRef();
  const cube2Material = useRef();
  const cube3Material = useRef();
  const cube4Material = useRef();

  //TODO: REFACTOR THE PARAGRAPHGS with forwardrefs
  //paragraphs ref
  const timeDefinition = useRef();
  const patienceDefintion = useRef();
  const andoridParagraph = useRef();
  const appleParagraph = useRef();
  const reactParagraph = useRef();

  const { nodes, animations } = useGLTF(process.env.PUBLIC_URL + "/all.glb");
  const { actions, mixer } = useAnimations(animations, mainContainer);
  const activeAnimation = useRef({});

  function play({ progress = 0.0, timeTweak = 0.0, animationLoop = LoopOnce }) {
    const action = activeAnimation.current;
    action.repetitions = 1;
    action.setLoop(animationLoop);

    if (action.time <= action._clip.duration - timeTweak) {
      //handle transform animation reset glitch
      action.reset().play();
      mixer.setTime((action._clip.duration / 100) * progress);
    } else {
      action.paused = true;
    }
  }

  useEffect(() => {
    if (!mainContainer.current) return;
    const { clock, camel, android, ios, react } = objectPositionsInSpace;

    const _ = anime({
      targets: mainContainer.current.position,
      x: [15.45, 15.45],
      y: [-0.6, -0.6],
      z: [681.4, 681.4],
      duration: 1,
      autoplay: true,
    });
    const __ = anime({
      targets: mainContainer.current.rotation,
      y: [Math.PI / 8, Math.PI / 8],
      duration: 1,
      autoplay: true,
    });

    //initial rotation
    const initialRotation = anime({
      targets: mainContainer.current.rotation,
      x: 0,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //store listener for intial anim
    const unsubscribeInitialAnimation = useStore.subscribe(
      (state) => state.initialAnimation,
      ({ progress }) => {
        initialRotation.seek(progress);
      }
    );

    //initial scaleDown for playing the go animation
    const scaleDown = anime({
      targets: secondaryContainer.current.scale,
      x: 1,
      y: 1,
      z: 1,
      duration: 500,
      autoplay: false,
    });

    //joining the cubes.
    const join = anime({
      targets: secondaryContainer.current.position,
      x: secondaryContainer.current.position.x - 2.6,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //bring cubes to the clock position
    const cubesToClockPosition = anime({
      targets: mainContainer.current.position,
      //small adjustments for the camera
      x: [15.45, clock.x - 2],
      y: [-0.6, clock.y + 8],
      z: [681.4, clock.z + 50],
      duration: 500,
      autoplay: false,
    });

    //rotate cubes to show good clock animation
    const cubesToClockRotation = anime({
      targets: mainContainer.current.rotation,
      y: [Math.PI / 8, Math.PI / 3],
      duration: 500,
      autoplay: false,
    });

    //show timeDefinition
    const timeDefinitionShow = anime({
      targets: timeDefinition.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide timeDefinition
    const timeDefinitionClose = anime({
      targets: timeDefinition.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //TODO: set clock colors

    //bring cubes to the camel position
    const cubesToCamelPosition = anime({
      targets: mainContainer.current.position,
      x: [clock.x - 4, camel.x - 10],
      y: [clock.y + 10, camel.y + 5],
      z: [clock.z + 20, camel.z + 40],
      duration: 500,
      autoplay: false,
    });

    //rotate cubes for camel anim
    const rotateCubesForCamelAnim = anime({
      targets: mainContainer.current.rotation,
      y: [0, -Math.PI / 3],
      duration: 500,
      autoplay: false,
    });

    //show patience definition
    const showPatienceDefinition = anime({
      targets: patienceDefintion.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide patience definition
    const hidePatienceDefinition = anime({
      targets: patienceDefintion.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //bring the cubes to android position
    const cubesToAndroidPosition = anime({
      targets: mainContainer.current.position,
      x: [camel.x - 4, android.x - 6],
      y: [camel.y + 5, android.y + 3],
      z: [camel.z + 20, android.z + 36],
      duration: 500,
      autoplay: false,
    });

    const rotateCubesForAndroidAnimation = anime({
      targets: mainContainer.current.rotation,
      y: [0, Math.PI / 3],
      duration: 500,
      autoplay: false,
    });

    //show android paragraph
    const showAndroidParagraph = anime({
      targets: andoridParagraph.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide android paragraph
    const hideAndroidParagraph = anime({
      targets: andoridParagraph.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //bring the cubes to apple position
    const cubesToApplePosition = anime({
      targets: mainContainer.current.position,
      x: [android.x + 2, ios.x + 15],
      y: [android.y, ios.y],
      z: [android.z + 20, ios.z + 40],
      duration: 500,
      autoplay: false,
    });
    //adjust helper cubes 4 apple animation
    //TODO: adjust

    //rotate main cubes for apple animation
    //TODO: adjust
    const cubesToAppleRotation = anime({
      targets: mainContainer.current.rotation,
      y: [Math.PI / 3, Math.PI / 2],
      duration: 500,
      autoplay: false,
    });

    //show apple paragraph
    const showAppleParagraph = anime({
      targets: appleParagraph.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hideAppleParagraph
    const hideAppleParagraph = anime({
      targets: appleParagraph.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //cubes to react animation
    const cubesToReactPosition = anime({
      targets: mainContainer.current.position,
      x: [ios.x - 4, react.x - 2],
      y: [ios.y, react.y + 2],
      z: [ios.z + 30, react.z + 20],
      duration: 500,
      autoplay: false,
    });

    //cubes to react rotation
    const cubesToReactRotation = anime({
      targets: mainContainer.current.rotation,
      y: Math.PI / 2, //TODO: check this
      duration: 500,
      autoplay: false,
    });

    //show react paragraph
    const showReactParagraph = anime({
      targets: reactParagraph.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //flower colors
    //TODO: add refs for cube materials or fowradref them from another file or use context and have them reused for performance
    //this initial time just go with local refs to save time (23:35 pm me to next day's 8:00 am me)

    const mainCubeMaterialToXColor = anime({
      targets: mainCubeFaceMaterial.current.color,
    });

    const {
      go,
      toClock,
      clockMove,
      toCamel,
      camelMove,
      toAndroid,
      androidMove,
      toApple,
      appleMove,
      toFlower,
      toPineapple,
      toCannon,
    } = actions;
    const unsubscribeExperieneStore = useStore.subscribe(
      (state) => state.experience,
      ({
        //last changed (very important)
        lastChanged,
        //intial animation
        initialJoinProgress,
        initialGoProgress,
        initialScaleProgress,

        //clock
        experienceCubesToClockPositionProgress,
        experienceCubesToClockRotationProgress,
        toClockProgress,
        clockMoveProgress,
        timeDefinitionProgress,
        clockCloseProgress,
        timeDefinitionCloseProgress,

        //camel
        cubesToCamelPositionProgress,
        cubesToCamelRotationProgress,
        toCamelProgress,
        patienceDefinitionProgress,
        camelMoveProgress,
        camelGoProgress,
        patienceDefitionCloseProgress,

        //android
        cubesToAndroidPositionProgress,
        cubesToAndroidRotationProgress,
        toAndroidProgress,
        androidParagraphProgress,
        androidMoveProgress,
        androidGoProgress,
        androidParagraphCloseProgress,

        //apple
        experienceCubesToApplePositionProgress,
        experienceCubesToAppleRotationProgress,
        toAppleProgress,
        appleParagraphProgress,
        appleMoveProgress,
        appleGoProgress,
        appleParagraphCloseProgress,

        //react
        cubesToReactPositionProgress,
        cubesToReactRotationProgress,
        //fower
        toFlowerProgress,
        flowerColorsProgress,
        flowerParagraphProgress,
        flowerParagraphCloseProgress,
        //pineapple
        toPineAppleProgress,
        pineappleColorsProgress,
        pineappleParagraphProgress,
        pineappleParagraphCloseProgress,
        //cannon
        toCannonProgress,
        cannonColorsProgress,
        cannonParagraphProgress,
        cannonParagraphCloseProgress,
      }) => {
        switch (lastChanged) {
          case "initialJoinProgress":
            join.seek(initialJoinProgress);
            break;
          case "initialScaleProgress":
            scaleDown.seek(initialScaleProgress);

            mixer.stopAllAction();
            break;
          case "initialGoProgress":
            if (activeAnimation.current !== go) {
              mixer.stopAllAction();
            }
            activeAnimation.current = go;
            play({
              progress: initialGoProgress,
              timeTweak: 0.1,
            });
            break;
          case "experienceCubesToClockPositionProgress":
            cubesToClockPosition.seek(experienceCubesToClockPositionProgress);
            break;
          case "experienceCubesToClockRotationProgress":
            cubesToClockRotation.seek(experienceCubesToClockRotationProgress);
            break;
          case "toClockProgress":
            if (activeAnimation.current !== toClock) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toClock;
            play({
              progress: toClockProgress,
              timeTweak: 0.1,
            });
            break;
          case "clockMoveProgress":
            if (activeAnimation.current !== clockMove) {
              mixer.stopAllAction();
            }
            activeAnimation.current = clockMove;
            play({
              animationLoop: LoopRepeat,
              repetitions: 1,
              progress: clockMoveProgress,
            });
            break;
          case "timeDefinitionProgress":
            timeDefinitionShow.seek(timeDefinitionProgress);
            break;
          case "clockCloseProgress":
            if (activeAnimation.current !== go) {
              mixer.stopAllAction();
            }
            activeAnimation.current = go;
            play({
              progress: clockCloseProgress,
              timeTweak: 0.1,
            });
            break;
          case "timeDefinitionCloseProgress":
            timeDefinitionClose.seek(timeDefinitionCloseProgress);
            break;
          case "cubesToCamelPositionProgress":
            cubesToCamelPosition.seek(cubesToCamelPositionProgress);
            break;
          case "cubesToCamelRotationProgress":
            rotateCubesForCamelAnim.seek(cubesToCamelRotationProgress);
            break;
          case "toCamelProgress":
            if (activeAnimation.current !== toCamel) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toCamel;
            play({
              progress: toCamelProgress,
              timeTweak: 0.1,
            });
            break;
          case "patienceDefinitionProgress":
            showPatienceDefinition.seek(patienceDefinitionProgress);
            break;
          case "camelMoveProgress":
            if (activeAnimation.current !== camelMove) {
              mixer.stopAllAction();
            }
            activeAnimation.current = camelMove;
            play({
              progress: camelMoveProgress,
              moveTweak: 0.055,
              animationLoop: LoopRepeat,
            });
            break;
          case "camelGoProgress":
            if (activeAnimation.current !== go) {
              mixer.stopAllAction();
            }
            activeAnimation.current = go;
            play({
              progress: camelGoProgress,
              timeTweak: 0.1,
            });
            break;
          case "patienceDefitionCloseProgress":
            hidePatienceDefinition.seek(patienceDefitionCloseProgress);
            break;
          case "cubesToAndroidPositionProgress":
            cubesToAndroidPosition.seek(cubesToAndroidPositionProgress);
            //TODO: animate color chages for cube materials and mabybe environment
            break;
          case "cubesToAndroidRotationProgress":
            rotateCubesForAndroidAnimation.seek(cubesToAndroidRotationProgress);
            //TODO: animate color chages for cube materials and mabybe environment
            break;
          case "toAndroidProgress":
            if (activeAnimation.current !== toAndroid) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toAndroid;
            play({
              timeTweak: 0.1,
              progress: toAndroidProgress,
            });
            break;
          case "androidParagraphProgress":
            showAndroidParagraph.seek(androidParagraphProgress);
            break;
          case "androidMoveProgress":
            if (activeAnimation.current !== androidMove) {
              mixer.stopAllAction();
            }
            activeAnimation.current = androidMove;
            play({
              moveTweak: 0.05,
              animationLoop: LoopRepeat,
              progress: androidMoveProgress,
            });
            break;
          case "androidGoProgress":
            if (activeAnimation.current !== go) {
              mixer.stopAllAction();
            }
            activeAnimation.current = go;

            play({
              progress: androidGoProgress,
              timeTweak: 0.1,
            });
            break;
          case "androidParagraphCloseProgress":
            hideAndroidParagraph.seek(androidParagraphCloseProgress);
            break;
          case "experienceCubesToApplePositionProgress":
            //TODO: FIX THE FISIBILITIY 4 WHEN GOING BACKWARDS
            //adjust cubes
            //TODO: ADJUST ALL CUBES AND ALSO ANIMATE THE COLORS HERE & MAYBE CHANGE THE DURATION TO 1000
            cubesToApplePosition.seek(experienceCubesToApplePositionProgress);

            cubesToAppleRotation.seek(experienceCubesToApplePositionProgress);
            break;
          case "experienceCubesToAppleRotationProgress":
            cubesToAppleRotation.seek(experienceCubesToAppleRotationProgress);
            break;
          case "toAppleProgress":
            if (activeAnimation.current !== toApple) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toApple;
            play({
              timeTweak: 0.1,
              animationLoop: LoopOnce,
              progress: toAppleProgress,
            });
            break;
          case "appleParagraphProgress":
            showAppleParagraph.seek(appleParagraphProgress);
            break;
          case "appleMoveProgress":
            if (activeAnimation.current !== appleMove) {
              mixer.stopAllAction();
            }
            activeAnimation.current = appleMove;
            play({
              animationLoop: LoopRepeat,
              progress: appleMoveProgress,
            });
            break;
          case "appleGoProgress":
            if (activeAnimation.current !== go) {
              mixer.stopAllAction();
            }
            activeAnimation.current = go;

            play({
              progress: appleGoProgress,
              timeTweak: 0.1,
            });
            break;
          case "appleParagraphCloseProgress":
            hideAppleParagraph.seek(appleParagraphCloseProgress);
            break;
          case "cubesToReactPositionProgress":
            cubesToReactPosition.seek(cubesToReactPositionProgress);
            break;
          case "cubesToReactRotationProgress":
            cubesToReactRotation.seek(cubesToReactRotationProgress);
            break;
          case "toFlowerProgress":
            if (activeAnimation.current !== toFlower) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toFlower;
            play({
              progress: toFlowerProgress,
              timeTweak: 0.15,
            });
            break;
          case "flowerColorsProgress":
            break;
          case "flowerParagraphProgress":
            showReactParagraph.seek(flowerParagraphProgress);
            break;
          case "flowerParagraphCloseProgress":
            break;
          case "toPineAppleProgress":
            if (activeAnimation.current !== toPineapple) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toPineapple;
            play({
              progress: toPineAppleProgress,
              timeTweak: 0.15,
            });
            break;
          case "pineappleColorsProgress":
            break;
          case "pineappleParagraphProgress":
            break;
          case "pineappleParagraphCloseProgress":
            break;
          case "toCannonProgress":
            if (activeAnimation.current !== toCannon) {
              mixer.stopAllAction();
            }
            activeAnimation.current = toCannon;
            play({
              progress: toCannonProgress,
              timeTweak: 0.15,
            });
            break;
          case "cannonColorsProgress":
            break;
          case "cannonParagraphProgress":
            break;
          case "cannonParagraphCloseProgress":
            break;
          default:
            break;
        }
      }
    );

    return () => {
      unsubscribeInitialAnimation();
      unsubscribeExperieneStore();
    };
  }, [mainContainer.current]);

  useFrame(() => {
    if (!activeAnimation.current) return;
    const { clockMove, camelMove, androidMove, appleMove } = actions;
    const acAnim = activeAnimation.current;
    if (
      acAnim === clockMove ||
      acAnim === androidMove ||
      acAnim === camelMove ||
      acAnim === androidMove
    ) {
      if (acAnim.time + 0.055 >= acAnim._clip.duration) {
        acAnim.time = 0.055;
      }
    } else if (acAnim === appleMove) {
      if (acAnim.time + 0.1 >= acAnim._clip.duration) {
        acAnim.time = 0.1;
      }
    }
  });

  return (
    <group
      position={[15.45, -0.6, 681.4]}
      rotation={[0, Math.PI / 8, 0]}
      ref={mainContainer}
      {...props}
      dispose={null}
    >
      <mesh
        name="cube"
        geometry={nodes.cube.geometry}
        material={nodes.cube.material}
        receiveShadow={true}
        morphTargetDictionary={nodes.cube.morphTargetDictionary}
        morphTargetInfluences={nodes.cube.morphTargetInfluences}
      >
        {/**this is the main cube */}
        <meshStandardMaterial
          {...nodes.cube.material}
          layers={2}
          roughness={0.8}
          metalness={0.2}
          emissive="green"
          ref={mainCubeMaterial}
        />
      </mesh>
      <mesh
        name="cube_1"
        geometry={nodes.cube_1.geometry}
        material={nodes.cube_1.material}
        morphTargetDictionary={nodes.cube_1.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_1.morphTargetInfluences}
      >
        {/** this is the face of the main cube */}
        <meshStandardMaterial
          {...nodes.cube_1.material}
          layers={2}
          emissive="#fff000"
          ref={mainCubeFaceMaterial}
        />
      </mesh>
      <group
        ref={secondaryContainer}
        position={[3.1, -0.25, 0]}
        scale={[1.255, 1.255, 1.255]}
      >
        <mesh
          name="cube_2"
          geometry={nodes.cube_2.geometry}
          material={nodes.cube_2.material}
          morphTargetDictionary={nodes.cube_2.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_2.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_2.material}
            layers={2}
            emissive="#00ff00"
            ref={cube1Material}
          />
        </mesh>
        <mesh
          name="cube_3"
          geometry={nodes.cube_3.geometry}
          material={nodes.cube_3.material}
          morphTargetDictionary={nodes.cube_3.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_3.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_3.material}
            layers={2}
            emissive="#ff00ff"
            ref={cube2Material}
          />
        </mesh>
        <mesh
          name="cube_4"
          geometry={nodes.cube_4.geometry}
          material={nodes.cube_4.material}
          morphTargetDictionary={nodes.cube_4.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_4.morphTargetInfluences}
        >
          <meshStandardMaterial layers={2} emissive="red" ref={cube3Material} />
        </mesh>
        <mesh
          name="cube_5"
          geometry={nodes.cube_5.geometry}
          material={nodes.cube_5.material}
          morphTargetDictionary={nodes.cube_5.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_5.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_5.material}
            layers={2}
            emissive="#ff00aa"
            ref={cube4Material}
          />
        </mesh>
      </group>
      <Time ref={timeDefinition} />
      <Patience ref={patienceDefintion} />
      <Android ref={andoridParagraph} />
      <IOS ref={appleParagraph} />
      <ReactJS ref={reactParagraph} />
    </group>
  );
}

useGLTF.preload(process.env.PUBLIC_URL + "/all.glb");
