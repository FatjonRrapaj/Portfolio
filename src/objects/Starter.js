/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { LoopOnce } from "three";
import { useFrame } from "@react-three/fiber";
export default function Model({ ...props }) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF(
    process.env.PUBLIC_URL + "/all.glb"
  );
  const { actions } = useAnimations(animations, group);
  console.log("actions: ", actions);

  const timeouts = useRef([]);

  const delay = (seconds) =>
    new Promise((resolve) => {
      const t = setTimeout(resolve, seconds * 1000);
      timeouts.current.push(t);
      return t;
    });

  const actionsPointer = useRef({
    transform: null,
    move: null,
    moveInfinite: false,
    transformTweak: 0,
    moveTweak: 0,
    reverseDelay: 0,
  });

  const assignActions = (number) => {
    const {
      androidMove,
      appleMove,
      camelMove,
      clockMove,
      toAndroid,
      toApple,
      toCamel,
      toCannon,
      toClock,
      toFlower,
      toPineapple,
    } = actions;

    switch (number) {
      case 0:
        //asign clock animations
        actionsPointer.current.transform = toClock;
        actionsPointer.current.move = clockMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.moveTweak = 0.05; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.reverseDelay = 7.75;
        break;
      case 1:
        //assign camel animations
        actionsPointer.current.transform = toCamel;
        actionsPointer.current.move = camelMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.moveTweak = 0.055; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.reverseDelay = 7.75;
        break;
      case 2:
        //assign android animations
        actionsPointer.current.transform = toAndroid;
        actionsPointer.current.move = androidMove;
        actionsPointer.current.moveInfinite = false;
        actionsPointer.current.transformTweak = 0; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.moveTweak = 0.05; //from manually testing the animations... sorry for the inconvience.
        actionsPointer.current.reverseDelay = 7.75;
        break;
      case 3:
        //assign apple animations
        actionsPointer.current.transform = toApple;
        actionsPointer.current.move = appleMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1; //from manually testing the animations... sorry for the inconvience. //try also 0
        actionsPointer.current.moveTweak = 0.1; //from manually testing the animations... sorry for the inconvience. //try also 0.05
        actionsPointer.current.reverseDelay = 7.75;
        break;
      case 4:
        //assign flower animations
        actionsPointer.current.transform = toFlower;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05; //from manually testing the animations... sorry for the inconvience.
        break;
      case 5:
        //assign pineapple animations
        actionsPointer.current.transform = toPineapple;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05;
        break;
      case 6:
        //assign cannon animations
        actionsPointer.current.transform = toCannon;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05;
      default:
        break;
    }
  };

  const startAnimations = async () => {
    const { come } = actions;
    const { transform, move, moveInfinite, moveTweak } = actionsPointer.current;
    //come
    come.repetitions = 1;
    come.play();
    await delay(come._clip.duration); //wait for animation to finish

    //transform animation
    transform.repetitions = 1;
    transform.play();
    await delay(transform._clip.duration);

    //move animation
    if (move) {
      if (moveInfinite) move.time = moveTweak;
      if (!moveInfinite) move.repetitions = 1;
      move.play();
    }
  };

  const endAnimations = async () => {
    const { go } = actions;
    const { transform, move, moveInfinite, reverseDelay, moveTweak } =
      actionsPointer.current;

    if (!move) {
      return;
    }
    //fake waiting
    await delay(8);

    //reverse move;
    move.reset();
    move.time = moveTweak;
    move.timeScale = -1;
    move.repetitions = 1;
    move.startAt(reverseDelay);
    move.play();
    await delay(move._clip.duration);

    //reverse transform
    transform.reset();
    transform.repetitions = 1;
    transform.timeScale = -1;
    transform.startAt(reverseDelay); //needs value???
    transform.play(); //+2 needed when going backwards
    await delay(2.75);

    go.repetitions = 1;
    go.clampWhenFinished = true;
    go.play();
  };

  // const playClockAnimations = async () => {
  //   const { come, toClock, clockMove, go } = actions;
  //   //come
  //   come.repetitions = 1;
  //   come.play();
  //   await delay(come._clip.duration); //wait for animation to finish
  //   //toClock
  //   toClock.repetitions = 1;
  //   toClock.play();
  //   await delay(toClock._clip.duration);
  //   //clockMove
  //   clockMove.time = 0.05; //avoid inbetween glitches
  //   clockMove.play();
  //   await delay(3); //false delay, to be removed (will be triggered from the scroll & raycaster)
  //   //reverse clockMove
  //   clockMove.reset();
  //   clockMove.timeScale = -1;
  //   clockMove.repetitions = 1;
  //   clockMove.startAt(0); //+2 needed when going backwards
  //   clockMove.play();
  //   await delay(clockMove._clip.duration);
  //   //reverse toClock
  //   toClock.reset();
  //   toClock.repetitions = 1;
  //   toClock.timeScale = -1;
  //   toClock.startAt(7.75); //needs value???
  //   toClock.play(); //+2 needed when going backwards
  //   await delay(toClock._clip.duration);
  //   //go
  //   go.repetitions = 1;
  //   go.clampWhenFinished = true;
  //   go.play();
  // };

  useEffect(() => {
    assignActions(5);
    startAnimations();
    endAnimations();

    return () => {
      for (let i = 0; i < timeouts.current.length; i++) {
        clearTimeout(timeouts[i]);
      }
    };
  }, []);

  useFrame(() => {
    //transform fixes
    const { transform, move, moveInfinite, transformTweak, moveTweak } =
      actionsPointer.current;
    if (!transform) {
      return;
    }
    if (transform.time >= transform._clip.duration - transformTweak) {
      transform.paused = true;
    }
    //move fixes
    if (!move) {
      return;
    }
    if (moveInfinite) {
      if (move.time >= move._clip.duration - moveTweak) {
        move.time = moveTweak;
      }
    } else {
      if (move.time >= move._clip.duration - moveTweak) {
        move.paused = true;
      }
    }

    if (actions.go.time >= actions.go._clip.duration - 0.1) {
      actions.go.paused = true;
    }
  });

  return (
    <group
      position={[0, 0, 692]}
      scale={[0.4, 0.4, 0.4]}
      rotation={[0, Math.PI / 6, 0]}
      ref={group}
      {...props}
      dispose={null}
    >
      <mesh
        name="cube"
        geometry={nodes.cube.geometry}
        material={nodes.cube.material}
        receiveShadow={true}
        morphTargetDictionary={nodes.cube.morphTargetDictionary}
        morphTargetInfluences={nodes.cube.morphTargetInfluences}
      >
        <meshStandardMaterial
          {...nodes.cube.material}
          layers={2}
          roughness={0.8}
          metalness={0.2}
          emissive="green"
        />
      </mesh>
      <mesh
        name="cube_1"
        geometry={nodes.cube_1.geometry}
        material={nodes.cube_1.material}
        morphTargetDictionary={nodes.cube_1.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_1.morphTargetInfluences}
      >
        <meshStandardMaterial
          {...nodes.cube_1.material}
          layers={2}
          emissive="#fff000"
        />
      </mesh>
      <mesh
        name="cube_2"
        geometry={nodes.cube_2.geometry}
        material={nodes.cube_2.material}
        morphTargetDictionary={nodes.cube_2.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_2.morphTargetInfluences}
      >
        <meshStandardMaterial
          {...nodes.cube_2.material}
          layers={2}
          emissive="#00ff00"
        />
      </mesh>
      <mesh
        name="cube_3"
        geometry={nodes.cube_3.geometry}
        material={nodes.cube_3.material}
        morphTargetDictionary={nodes.cube_3.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_3.morphTargetInfluences}
      >
        <meshStandardMaterial
          {...nodes.cube_3.material}
          layers={2}
          emissive="#ff00ff"
        />
      </mesh>
      <mesh
        name="cube_4"
        geometry={nodes.cube_4.geometry}
        material={nodes.cube_4.material}
        morphTargetDictionary={nodes.cube_4.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_4.morphTargetInfluences}
      >
        <meshStandardMaterial layers={2} emissive="red" />
      </mesh>
      <mesh
        name="cube_5"
        geometry={nodes.cube_5.geometry}
        material={nodes.cube_5.material}
        morphTargetDictionary={nodes.cube_5.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_5.morphTargetInfluences}
      >
        <meshStandardMaterial
          {...nodes.cube_5.material}
          layers={2}
          emissive="#ff00aa"
        />
      </mesh>
    </group>
  );
}

useGLTF.preload(process.env.PUBLIC_URL + "/all.glb");
