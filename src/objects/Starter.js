/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, createRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import useStore from "../store";
import anime from "animejs/lib/anime.es";
import { useControls } from "leva";

import Paragraph from "./paragraphs/Paragraph";
import { seekGltfAnimation } from "../helpers/animation";
import { objectPositionsInSpace } from "./constants";
import { AnimationMixer, LoopRepeat, LoopOnce, LoopPingPong } from "three";
import { AnimationAction } from "three/src/animation/AnimationAction";

//https://discourse.threejs.org/t/playing-an-animation-changes-behaviour-of-next-animation/14928/7

export default function Model({ ...props }) {
  const { camera } = useThree();
  console.log("camera: ", camera.position);

  //cube refs
  const mainContainer = useRef();
  const secondaryContainer = useRef();

  //material refs
  const mainCubeMaterial = useRef();
  const mainCubeFaceMaterial = useRef();
  const cube1Material = useRef();
  const cube2Material = useRef();
  const cube3Material = useRef();
  const cube4Material = useRef();

  const { nodes, materials, animations } = useGLTF(
    process.env.PUBLIC_URL + "/all.glb"
  );
  const { actions, mixer } = useAnimations(animations, mainContainer);
  console.log("mixer: ", mixer);

  //refs
  const timeouts = useRef([]);

  //paragraphs ref
  const timeDefinition = useRef();
  const patienceDefintion = useRef();
  const andoridParagraph = useRef();
  const appleParagraph = useRef();

  const delay = (seconds) =>
    new Promise((resolve) => {
      const t = setTimeout(resolve, seconds * 1000);
      timeouts.current.push(t);
      return t;
    });

  const actionsPointer = useRef({
    transform: null,
    move: null,
    moveInfinite: false, //if the moving animation is repeating or not.
    fromLastPosition: false, //animation should start from where the object is, not from moving.
    transformTweak: 0, //from manually testing the animations... sorry for the inconvience.
    moveTweak: 0, //from manually testing the animations... sorry for the inconvience.
    reverseDelay: 0, //from manually testing the animations... sorry for the inconvience.
  });

  //pargraphs show & hide
  // const timeDefinitionScale = useRef([0,0,0])

  const assignActions = (number) => {
    const {
      androidMove,
      appleMove,
      camelMove,
      clockMove,
      toAndroid,
      toApple,
      toCamel,
      toCannon,
      toClock,
      toFlower,
      toPineapple,
    } = actions;

    switch (number) {
      case 0:
        //asign clock animations
        actionsPointer.current.transform = toClock;
        actionsPointer.current.move = clockMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1;
        actionsPointer.current.moveTweak = 0.05;
        actionsPointer.current.reverseDelay = 7.75;
        actionsPointer.current.fromLastPosition = false;
        break;
      case 1:
        //assign camel animations
        actionsPointer.current.transform = toCamel;
        actionsPointer.current.move = camelMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1;
        actionsPointer.current.moveTweak = 0.055;
        actionsPointer.current.reverseDelay = 7.75;
        actionsPointer.current.fromLastPosition = false;
        break;
      case 2:
        //assign android animations
        actionsPointer.current.transform = toAndroid;
        actionsPointer.current.move = androidMove;
        actionsPointer.current.moveInfinite = false;
        actionsPointer.current.transformTweak = 0;
        actionsPointer.current.moveTweak = 0.05;
        actionsPointer.current.reverseDelay = 7.75;
        actionsPointer.current.fromLastPosition = false;
        break;
      case 3:
        //assign apple animations
        actionsPointer.current.transform = toApple;
        actionsPointer.current.move = appleMove;
        actionsPointer.current.moveInfinite = true;
        actionsPointer.current.transformTweak = 0.1; //try also 0
        actionsPointer.current.moveTweak = 0.1; //try also 0.05
        actionsPointer.current.reverseDelay = 7.75;
        actionsPointer.current.fromLastPosition = false;
        break;
      case 4:
        //assign flower animations
        actionsPointer.current.transform = toFlower;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05;
        actionsPointer.current.fromLastPosition = false;
        break;
      case 5:
        //assign pineapple animations
        actionsPointer.current.transform = toPineapple;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05;
        actionsPointer.current.fromLastPosition = true;
        break;
      case 6:
        //assign cannon animations
        actionsPointer.current.transform = toCannon;
        actionsPointer.current.move = null;
        actionsPointer.current.transformTweak = 0.05;
        actionsPointer.current.fromLastPosition = true;
      default:
        break;
    }
  };

  const startAnimations = async () => {
    const { come } = actions;
    const {
      transform,
      transformTweak,
      move,
      moveInfinite,
      moveTweak,
      fromLastPosition,
    } = actionsPointer.current;

    if (!fromLastPosition) {
      //come
      come.repetitions = 1;
      come.play();
      await delay(come._clip.duration); //wait for animation to finish
    }

    //transform animation
    transform.repetitions = 1;
    transform.play();
    await delay(transform._clip.duration - transformTweak);

    //move animation
    if (move) {
      if (moveInfinite) move.time = moveTweak;
      if (!moveInfinite) move.repetitions = 1;
      move.play();
    }
  };

  const endAnimations = async () => {
    const { go } = actions;
    const { transform, move, reverseDelay, moveTweak } = actionsPointer.current;

    if (!move) {
      return;
    }
    //fake waiting
    await delay(8);

    //reverse move;
    move.reset();
    move.time = moveTweak;
    move.timeScale = -1;
    move.repetitions = 1;
    move.startAt(reverseDelay);
    move.play();
    await delay(move._clip.duration);

    //reverse transform
    transform.reset();
    transform.repetitions = 1;
    transform.timeScale = -1;
    transform.startAt(reverseDelay);
    transform.play(); //+2 needed when going backwards
    await delay(2.75);

    go.repetitions = 1;
    go.clampWhenFinished = true;
    go.play();
  };

  //for controling backward and forward playing of GLTF animations
  //initial animation
  const initialGoProgressChecker = useRef(0);

  //clock
  const toClockProgressChecker = useRef(0);
  const clockMoveProgressChecker = useRef(0);
  const clockCloseProgressChecker = useRef(0);

  //camel
  const toCamelProgressChecker = useRef(0);
  const camelMoveProgressChecker = useRef(0);
  const camelGoProgressChecker = useRef(0);

  //android
  const toAndroidProgressChecker = useRef(0);
  const androidMoveProgressChecker = useRef(0);
  const androidGoProgressChecker = useRef(0);

  //apple
  const toAppleProgressChecker = useRef(0);
  const appleMoveProgressChecker = useRef(0);
  const appleGoProgressChecker = useRef(0);

  //react
  const toFlowerProgressChecker = useRef(0);
  const toPineappleProgressChecker = useRef(0);
  const toCannonProgressChecker = useRef(0);

  const currAction = useRef(null);
  const prevAction = useRef(null);

  function play(
    {
      mixer,
      action,
      progress = 0,
      timeTweak = 0,
      clampWhenFinished,
      repetitions = 1,
      playbackController,
      customAnimationDuration = 2000,
      animationLoop = LoopOnce,
      prevAction = null,
    } = {
      action: [AnimationAction], //the actions, auto genearated by pmndrs-drei (gltfjsx)
      mixer: AnimationMixer, //the animation mixer auto genearated by pmndrs-drei (gltfjsx)
      progress: Number, // the progress passed from the timeline progress
      timeTweak: Number, //tweak to pause before time
      clampWhenFinished: Boolean, //https://threejs.org/docs/#api/en/animation/AnimationAction.clampWhenFinished
      repetitions: Number,
      playbackController: Number, //a ref that check if the animation is playing backwards
      customAnimationDuration: Number | null, //provided if there's a custom animation duration. should be the same as the timeile duration in animationHandler.js
      animationLoop: Number, //Animation action loop styles
      prevAction: AnimationAction | null, //the previous anmation action, should be a ref
    }
  ) {
    action.reset().play();
    action.timeScale = 1;
    action.clampWhenFinished = false;
    action.repetitions = repetitions;
    action.setLoop(animationLoop);

    if (customAnimationDuration) {
      action.setDuration(customAnimationDuration);
    }
    if (playbackController.current > progress) {
      const duration = customAnimationDuration
        ? customAnimationDuration
        : action._clip.duration;
      const factor = duration / 100;
      mixer.setTime(progress * factor);
    } else {
      //animation is playing forward
      action.timeScale = 1;
      const currTime = (action._clip.duration * progress) / 100;
      mixer.setTime(currTime);
    }

    //very important
    playbackController.current = progress;
  }

  useEffect(() => {
    // assignActions(6);
    // startAnimations();
    // endAnimations();

    //return refs are not do not have values yet.
    if (!mainContainer.current) return;

    const {
      planeInitialPosition: initialPosition,
      clock,
      camel,
      android,
      ios,
      react,
    } = objectPositionsInSpace;

    const _ = anime({
      targets: mainContainer.current.position,
      x: [15.45, 15.45],
      y: [-0.6, -0.6],
      z: [681.4, 681.4],
      duration: 1,
      autoplay: true,
    });

    //initial rotation
    const initialRotation = anime({
      targets: mainContainer.current.rotation,
      x: 0,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //store listener for intial anim
    const unsubscribeInitialAnimation = useStore.subscribe(
      (state) => state.initialAnimation,
      ({ progress }) => {
        initialRotation.seek(progress);
      }
    );

    //initial scaleDown for playing the go animation
    const scaleDown = anime({
      targets: secondaryContainer.current.scale,
      x: 1,
      y: 1,
      z: 1,
      duration: 500,
      autoplay: false,
    });

    //joining the cubes.
    const join = anime({
      targets: secondaryContainer.current.position,
      x: secondaryContainer.current.position.x - 2.6,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //bring cubes to the clock position
    const cubesToClockPosition = anime({
      targets: mainContainer.current.position,
      //small adjustments for the camera
      x: [15.45, clock.x - 2],
      y: [-0.6, clock.y + 8],
      z: [681.4, clock.z + 50],
      duration: 500,
      autoplay: false,
    });

    const subCubesToClockPosition = anime({
      targets: secondaryContainer.current.position,
      x: 0.5,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //rotate cubes to show good clock animation
    const cubesToClockRotation = anime({
      targets: mainContainer.current.rotation,
      y: Math.PI / 3,
      duration: 500,
      autoplay: false,
    });

    //show timeDefinition
    const timeDefinitionShow = anime({
      targets: timeDefinition.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide timeDefinition
    const timeDefinitionClose = anime({
      targets: timeDefinition.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //TODO: set clock colors

    //bring cubes to the camel position
    const cubesToCamelPosition = anime({
      targets: mainContainer.current.position,
      x: [clock.x - 4, camel.x - 10],
      y: [clock.y + 8, camel.y + 5],
      z: [clock.z + 20, camel.z + 40],
      duration: 500,
      autoplay: false,
    });

    //secondary cubes andjustment for camel animation
    const subCubesToCamelPosition = anime({
      targets: secondaryContainer.current.position,
      x: 0.5,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //rotate cubes for camel anim
    const rotateCubesForCamelAnim = anime({
      targets: mainContainer.current.rotation,
      y: -Math.PI / 3,
      duration: 500,
      autoplay: false,
    });

    //show patience definition
    const showPatienceDefinition = anime({
      targets: patienceDefintion.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide patience definition
    const hidePatienceDefinition = anime({
      targets: patienceDefintion.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //bring the cubes to android position
    const cubesToAndroidPosition = anime({
      targets: mainContainer.current.position,
      x: [camel.x - 10, android.x - 6],
      y: [camel.y + 5, android.y + 3],
      z: [camel.z + 10, android.z + 36],
      duration: 500,
      autoplay: false,
    });

    const subCubesToAndroidPosition = anime({
      targets: secondaryContainer.current.position,
      x: 0.5,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    const rotateCubesForAndroidAnimation = anime({
      targets: mainContainer.current.rotation,
      y: Math.PI / 3,
      duration: 500,
      autoplay: false,
    });

    //show android paragraph
    const showAndroidParagraph = anime({
      targets: andoridParagraph.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hide android paragraph
    const hideAndroidParagraph = anime({
      targets: andoridParagraph.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //bring the cubes to apple position
    const cubesToApplePosition = anime({
      targets: mainContainer.current.position,
      x: [android.x - 8, ios.x + 15],
      y: [android.y + 2, ios.y],
      z: [android.z + 10, ios.z + 40],
      duration: 500,
      autoplay: false,
    });
    //adjust helper cubes 4 apple animation
    //TODO: adjust
    const subCubesToApplePosition = anime({
      targets: secondaryContainer.current.position,
      x: 0,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });
    //rotate main cubes for apple animation
    //TODO: adjust
    const cubesToAppleRotation = anime({
      targets: mainContainer.current.rotation,
      y: Math.PI / 3,
      duration: 500,
      autoplay: false,
    });

    //show apple paragraph
    const showAppleParagraph = anime({
      targets: appleParagraph.current.style,
      opacity: 1,
      duration: 500,
      autoplay: false,
    });

    //hideAppleParagraph
    const hideAppleParagraph = anime({
      targets: appleParagraph.current.style,
      opacity: 0,
      duration: 500,
      autoplay: false,
    });

    //cubes to react animation
    const cubesToReactPosition = anime({
      targets: mainContainer.current.position,
      x: [ios.x + 15, react.x - 2],
      y: [ios.y, react.y + 4],
      z: [ios.z + 20, react.z + 50],
      duration: 500,
      autoplay: false,
    });

    //secondaryCubes cubes to react animation
    const subCubesToReactPosition = anime({
      targets: secondaryContainer.current.position,
      //TODO: change this
      x: -0.2,
      y: 0,
      z: 0,
      duration: 500,
      autoplay: false,
    });

    //cubes to react rotation
    const cubesToReactRotation = anime({
      targets: mainContainer.current.rotation,
      // y: Math.PI / 2, //TODO: check this
      duration: 500,
      autoplay: false,
    });

    //flower colors
    //TODO: add refs for cube materials or fowradref them from another file or use context and have them reused for performance
    //this initial time just go with local refs to save time (23:35 pm me to next day's 8:00 am me)

    const mainCubeMaterialToXColor = anime({
      targets: mainCubeFaceMaterial.current.color,
    });

    //LEFT HERE. <= check the file on the left and add the animation handlers at the swiths tatement here, also at the plane.
    // q2#!!A>Sd

    const {
      go,
      toClock,
      clockMove,
      toCamel,
      camelMove,
      toAndroid,
      androidMove,
      toApple,
      appleMove,
      toFlower,
      toPineapple,
      toCannon,
    } = actions;
    const unsubscribeExperieneStore = useStore.subscribe(
      (state) => state.experience,
      ({
        //last changed (very important)
        lastChanged,
        //intial animation
        initialJoinProgress,
        initialGoProgress,
        initialScaleProgress,

        //clock
        experienceCubesToClockPositionProgress,
        toClockProgress,
        clockMoveProgress,
        timeDefinitionProgress,
        clockCloseProgress,
        timeDefinitionCloseProgress,

        //camel
        cubesToCamelPositionProgress,
        toCamelProgress,
        patienceDefinitionProgress,
        camelMoveProgress,
        camelGoProgress,
        patienceDefitionCloseProgress,

        //android
        cubesToAndroidPositionProgress,
        toAndroidProgress,
        androidParagraphProgress,
        androidMoveProgress,
        androidGoProgress,
        androidParagraphCloseProgress,

        //apple
        experienceCubesToApplePositionProgress,
        toAppleProgress,
        appleParagraphProgress,
        appleMoveProgress,
        appleGoProgress,
        appleParagraphCloseProgress,

        //react
        cubesToReactPositionProgress,
        //fower
        toFlowerProgress,
        flowerColorsProgress,
        flowerParagraphProgress,
        flowerParagraphCloseProgress,
        //pineapple
        toPineAppleProgress,
        pineappleColorsProgress,
        pineappleParagraphProgress,
        pineappleParagraphCloseProgress,
        //cannon
        toCannonProgress,
        cannonColorsProgress,
        cannonParagraphProgress,
        cannonParagraphCloseProgress,
      }) => {
        switch (lastChanged) {
          case "initialJoinProgress":
            join.seek(initialJoinProgress);
            break;
          case "initialScaleProgress":
            scaleDown.seek(initialScaleProgress);
            break;
          case "initialGoProgress":
            if (initialGoProgress > 90) {
              mainContainer.current.visible = false;
            } else {
              mainContainer.current.visible = true;
            }
            if (actionsPointer.current.transform != go) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = go;
            play({
              action: go,
              mixer,
              progress: initialGoProgress,
              playbackController: initialGoProgressChecker,
              timeTweak: 0,
              clampWhenFinished: true,
              repetitions: 1,
              customAnimationDuration: 1000,
              prevAction: prevAction,
            });

            break;
          case "experienceCubesToClockPositionProgress":
            mainContainer.current.visible = true;
            cubesToClockPosition.seek(experienceCubesToClockPositionProgress);
            cubesToClockRotation.seek(experienceCubesToClockPositionProgress);
            subCubesToClockPosition.seek(
              experienceCubesToClockPositionProgress
            );
            break;
          case "toClockProgress":
            if (actionsPointer.current.transform != toClock) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = toClock;
            actionsPointer.current.transformTweak = 10;
            play({
              currAction,
              action: toClock,
              progress: toClockProgress,
              clampWhenFinished: false,
              playbackController: toClockProgressChecker,
              customAnimationDuration: 2000,
              repetitions: 1,
              prevAction,
              mixer,
            });
            break;
          case "clockMoveProgress":
            if (
              actionsPointer.current.transform != clockMove &&
              actionsPointer.current.transform != toClock
            ) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = clockMove;

            play({
              action: clockMove,
              progress: clockMoveProgress,
              playbackController: clockMoveProgressChecker,
              customAnimationduration: 100,
              repetitions: 10,
              prevAction,
              clampWhenFinished: false,
              animationLoop: LoopRepeat,
              mixer,
            });

          case "timeDefinitionProgress":
            timeDefinitionShow.seek(timeDefinitionProgress);
            break;
          case "clockCloseProgress":
            if (actionsPointer.current.transform != go) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = go;
            actionsPointer.current.transformTweak = 1;

            if (clockCloseProgress > 90) {
              mainContainer.current.visible = false;
            } else {
              mainContainer.current.visible = true;
            }
            play({
              currAction,
              action: go,
              progress: clockCloseProgress,
              playbackController: clockCloseProgressChecker,
              customAnimationDuration: 1000,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopOnce,
              mixer,
            });
            break;
          case "timeDefinitionCloseProgress":
            timeDefinitionClose.seek(timeDefinitionCloseProgress);
            break;
          case "cubesToCamelPositionProgress":
            mainContainer.current.visible = true;
            cubesToCamelPosition.seek(cubesToCamelPositionProgress);
            // subCubesToCamelPosition.seek(cubesToCamelPositionProgress);
            rotateCubesForCamelAnim.seek(cubesToCamelPositionProgress);
            break;
          case "toCamelProgress":
            if (actionsPointer.current.transform != toCamel) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = toCamel;
            actionsPointer.current.transformTweak = 0.5;
            play({
              action: toCamel,
              progress: toCamelProgress,
              playbackController: toCamelProgressChecker,
              customAnimationDuration: 2000,
              repetitions: 1,
              prevAction,
              clampWhenFinished: false,
              animationLoop: LoopOnce,
              mixer,
            });
            break;
          case "patienceDefinitionProgress":
            showPatienceDefinition.seek(patienceDefinitionProgress);
            break;
          case "camelMoveProgress":
            if (
              actionsPointer.current.transform != camelMove &&
              actionsPointer.current.transform != toCamel
            ) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = camelMove;
            actionsPointer.current.move = camelMove;
            actionsPointer.current.moveTweak = 0.06;
            play({
              action: camelMove,
              progress: camelMoveProgress,
              playbackController: camelMoveProgressChecker,
              customAnimationduration: 1,
              repetitions: 1,
              prevAction,
              clampWhenFinished: false,
              animationLoop: LoopRepeat,
              mixer,
            });
            break;
          case "camelGoProgress":
            if (actionsPointer.current.transform != go) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = go;
            if (camelGoProgress > 90) {
              mainContainer.current.visible = false;
            } else {
              mainContainer.current.visible = true;
            }
            play({
              currAction,
              action: go,
              progress: camelGoProgress,
              playbackController: camelGoProgressChecker,
              customAnimationDuration: 1000,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopOnce,
              mixer,
            });
            break;
          case "patienceDefitionCloseProgress":
            hidePatienceDefinition.seek(patienceDefitionCloseProgress);
            break;
          case "cubesToAndroidPositionProgress":
            mainContainer.current.visible = true;
            cubesToAndroidPosition.seek(cubesToAndroidPositionProgress);
            subCubesToAndroidPosition.seek(cubesToAndroidPositionProgress);
            rotateCubesForAndroidAnimation.seek(cubesToAndroidPositionProgress);
            //TODO: animate color chages for cube materials and mabybe environment
            break;
          case "toAndroidProgress":
            if (actionsPointer.current.transform != toAndroid) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = toAndroid;
            play({
              mixer,
              action: toAndroid,
              repetitions: 1,
              clampWhenFinished: false,
              prevAction,
              playbackController: toAndroidProgressChecker,
              progress: toAndroidProgress,
              customAnimationDuration: 2000,
              animationLoop: LoopOnce,
            });
            break;
          case "androidParagraphProgress":
            showAndroidParagraph.seek(androidParagraphProgress);
            actionsPointer.current.moveInfinite = false;
            actionsPointer.current.moveTweak = 0.1;
            break;
          case "androidMoveProgress":
            if (
              actionsPointer.current.transform != toAndroid &&
              actionsPointer.current.transform != androidMove
            ) {
              mixer.stopAllAction();
            }
            actionsPointer.current.move = androidMove;
            actionsPointer.current.transform = toAndroid;
            play({
              mixer,
              action: androidMove,
              repetitions: 1,
              prevAction,
              clampWhenFinished: false,
              animationLoop: LoopRepeat,
              customAnimationduration: 1,
              progress: androidMoveProgress,
              playbackController: androidMoveProgressChecker,
            });
            break;
          case "androidGoProgress":
            if (actionsPointer.current.transform != go) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = go;
            actionsPointer.current.transform = go;
            if (androidGoProgress > 90) {
              mainContainer.current.visible = false;
            } else {
              mainContainer.current.visible = true;
            }
            // if (androidMoveProgressChecker > androidGoProgress) {
            //   prevAction.current = toApple;
            // } else {
            //   prevAction.current = androidMove;
            // }
            play({
              mixer,
              action: go,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopOnce,
              customAnimationDuration: 1000,
              progress: androidGoProgress,
              playbackController: androidGoProgressChecker,
            });
            break;
          case "androidParagraphCloseProgress":
            hideAndroidParagraph.seek(androidParagraphCloseProgress);
            break;
          case "experienceCubesToApplePositionProgress":
            //TODO: FIX THE FISIBILITIY 4 WHEN GOING BACKWARDS
            mainContainer.current.visible = true;
            //adjust cubes
            //TODO: ADJUST ALL CUBES AND ALSO ANIMATE THE COLORS HERE & MAYBE CHANGE THE DURATION TO 1000
            cubesToApplePosition.seek(experienceCubesToApplePositionProgress);
            subCubesToApplePosition.seek(
              experienceCubesToApplePositionProgress
            );
            cubesToAppleRotation.seek(experienceCubesToApplePositionProgress);
            //assign actions to apple animation (transform & move)
            break;
          case "toAppleProgress":
            if (actionsPointer.current.transform != toApple) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = toApple;
            actionsPointer.current.transformTweak = 0.1;
            // if (toAppleProgressChecker > toAppleProgress) {
            //   prevAction.current = appleMove;
            // } else {
            //   prevAction.current = go;
            // }
            play({
              mixer,
              action: toApple,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopOnce,
              customAnimationDuration: 2000,
              progress: toAppleProgress,
              playbackController: toAppleProgressChecker,
            });
            break;
          case "appleParagraphProgress":
            showAppleParagraph.seek(appleParagraphProgress);
            //assign transform action to go
            actionsPointer.current.transform = go;
            actionsPointer.current.transformTweak = 0.1;
            break;
          case "appleMoveProgress":
            if (
              actionsPointer.current.transform != toApple &&
              actionsPointer.current.transform != appleMove
            ) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = appleMove;
            actionsPointer.current.move = appleMove;
            actionsPointer.current.moveTweak = 0.1;
            play({
              mixer,
              action: appleMove,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopRepeat,
              customAnimationduration: 1,
              progress: appleMoveProgress,
              playbackController: appleMoveProgressChecker,
            });
            break;
          case "appleGoProgress":
            if (actionsPointer.current.transform != go) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transform = go;
            if (appleGoProgress > 90) {
              mainContainer.current.visible = false;
            } else {
              mainContainer.current.visible = true;
            }
            play({
              mixer,
              action: go,
              repetitions: 1,
              prevAction,
              clampWhenFinished: true,
              animationLoop: LoopOnce,
              customAnimationDuration: 1000,
              progress: appleGoProgress,
              playbackController: appleGoProgressChecker,
            });
            break;
          case "appleParagraphCloseProgress":
            hideAppleParagraph.seek(appleParagraphCloseProgress);
            break;
          case "cubesToReactPositionProgress":
            mainContainer.current.visible = true;
            cubesToReactPosition.seek(cubesToReactPositionProgress);
            break;
          case "toFlowerProgress":
            if (actionsPointer.current.transform != toFlower) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transformTweak = toFlower;
            play({
              action: toFlower,
              progress: toFlowerProgress,
              playbackController: toFlowerProgressChecker,
              customAnimationDuration: 2000,
              animationLoop: LoopOnce,
              clampWhenFinished: true,
              mixer,
              repetitions: 1,
            });
            break;
          case "flowerColorsProgress":
            break;
          case "flowerParagraphProgress":
            break;
          case "flowerParagraphCloseProgress":
            break;
          case "toPineAppleProgress":
            if (actionsPointer.current.transform != toPineapple) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transformTweak = toPineapple;
            play({
              action: toPineapple,
              progress: toPineAppleProgress,
              playbackController: toPineappleProgressChecker,
              customAnimationDuration: 2000,
              animationLoop: LoopOnce,
              clampWhenFinished: true,
              mixer,
              repetitions: 1,
            });
            break;
          case "pineappleColorsProgress":
            break;
          case "pineappleParagraphProgress":
            break;
          case "pineappleParagraphCloseProgress":
            break;
          case "toCannonProgress":
            if (actionsPointer.current.transform != toCannon) {
              mixer.stopAllAction();
            }
            actionsPointer.current.transformTweak = toCannon;
            play({
              action: toCannon,
              progress: toCannonProgress,
              playbackController: toCannonProgressChecker,
              customAnimationDuration: 2000,
              animationLoop: LoopOnce,
              clampWhenFinished: true,
              mixer,
              repetitions: 1,
            });
            break;
          case "cannonColorsProgress":
            break;
          case "cannonParagraphProgress":
            break;
          case "cannonParagraphCloseProgress":
            break;
          default:
            break;
        }
      }
    );

    return () => {
      unsubscribeInitialAnimation();
      unsubscribeExperieneStore();
      for (let i = 0; i < timeouts.current.length; i++) {
        clearTimeout(timeouts[i]);
      }
    };
  }, [mainContainer.current]);

  useFrame(() => {
    // move anim fixes
    const moveAnimExists = actionsPointer?.current?.move?.time;
    if (!!moveAnimExists) {
      const moveAnimTime = actionsPointer.current.move.time;
      const moveAnimDuration = actionsPointer.current.move._clip.duration;
      const moveAnimTweak = actionsPointer.current.moveTweak;
      if (moveAnimTime >= moveAnimDuration - moveAnimTweak) {
        actionsPointer.current.move.time = moveAnimTweak;
      }
    }

    //transform anim fixes
    const transformAnimExists = actionsPointer?.current?.transform?.time;
    if (!!transformAnimExists) {
      const transformAnimTime = actionsPointer.current.transform.time;

      const transformAnimDuration =
        actionsPointer.current.transform._clip.duration;
      const transformAnimTweak = actionsPointer.current.transformTweak;

      if (transformAnimTime >= transformAnimDuration - transformAnimTweak) {
        actionsPointer.current.transform.paused = true;
      }
    }
  });

  return (
    <group
      position={[15.45, -0.6, 681.4]}
      rotation={[0, Math.PI / 8, 0]}
      ref={mainContainer}
      {...props}
      dispose={null}
    >
      <mesh
        name="cube"
        geometry={nodes.cube.geometry}
        material={nodes.cube.material}
        receiveShadow={true}
        morphTargetDictionary={nodes.cube.morphTargetDictionary}
        morphTargetInfluences={nodes.cube.morphTargetInfluences}
      >
        {/**this is the main cube */}
        <meshStandardMaterial
          {...nodes.cube.material}
          layers={2}
          roughness={0.8}
          metalness={0.2}
          emissive="green"
          ref={mainCubeMaterial}
        />
      </mesh>
      <mesh
        name="cube_1"
        geometry={nodes.cube_1.geometry}
        material={nodes.cube_1.material}
        morphTargetDictionary={nodes.cube_1.morphTargetDictionary}
        morphTargetInfluences={nodes.cube_1.morphTargetInfluences}
      >
        {/** this is the face of the main cube */}
        <meshStandardMaterial
          {...nodes.cube_1.material}
          layers={2}
          emissive="#fff000"
          ref={mainCubeFaceMaterial}
        />
      </mesh>
      <group
        ref={secondaryContainer}
        position={[3.25, -0.25, 0]}
        scale={[1.255, 1.255, 1.255]}
      >
        <mesh
          name="cube_2"
          geometry={nodes.cube_2.geometry}
          material={nodes.cube_2.material}
          morphTargetDictionary={nodes.cube_2.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_2.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_2.material}
            layers={2}
            emissive="#00ff00"
            ref={cube1Material}
          />
        </mesh>
        <mesh
          name="cube_3"
          geometry={nodes.cube_3.geometry}
          material={nodes.cube_3.material}
          morphTargetDictionary={nodes.cube_3.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_3.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_3.material}
            layers={2}
            emissive="#ff00ff"
            ref={cube2Material}
          />
        </mesh>
        <mesh
          name="cube_4"
          geometry={nodes.cube_4.geometry}
          material={nodes.cube_4.material}
          morphTargetDictionary={nodes.cube_4.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_4.morphTargetInfluences}
        >
          <meshStandardMaterial layers={2} emissive="red" ref={cube3Material} />
        </mesh>
        <mesh
          name="cube_5"
          geometry={nodes.cube_5.geometry}
          material={nodes.cube_5.material}
          morphTargetDictionary={nodes.cube_5.morphTargetDictionary}
          morphTargetInfluences={nodes.cube_5.morphTargetInfluences}
        >
          <meshStandardMaterial
            {...nodes.cube_5.material}
            layers={2}
            emissive="#ff00aa"
            ref={cube4Material}
          />
        </mesh>
      </group>
      {/**Time paragraph */}
      <Paragraph ref={timeDefinition} />

      {/**Patience paragraph */}
      <Paragraph
        ref={patienceDefintion}
        position={[-22, 2, 0]}
        title="Patience"
        pronounciation="/ËˆpeÉªÊƒ(É™)ns/"
        definition="Sometimes I put myself in difficult circumstances ðŸ˜¤"
        sentence1="Just to endure them ðŸ’ª"
        sentence2="Don't worry, I tend not to do this in work-related stuff"
        conclusion="If we don't train our patience, we cannot acomplish bigger things"
      />

      {/**TODO: EDIt the EXPERIENCE PARAGRAPHS IN THE RIGHT WAY */}
      <Paragraph
        ref={andoridParagraph}
        position={[30, 0, 0]}
        title="Android"
        pronounciation="/ËˆandrÉ”Éªd/"
        definition="I started my career as an Android Developer"
        sentence1="Just to endure them ðŸ’ª"
        sentence2="Don't worry, I tend not to do this in work-related stuff"
        conclusion="If we don't train our patience, we cannot acomplish bigger things"
      />
      {/**TODO: EDIt the EXPERIENCE PARAGRAPHS IN THE RIGHT WAY */}

      <Paragraph ref={appleParagraph} title="Apple/iOS" />
    </group>
  );
}

useGLTF.preload(process.env.PUBLIC_URL + "/all.glb");

//700 lines and still going, do consider refactoring
