/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useEffect, useState } from "react";
import * as THREE from "three";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useLoader } from "@react-three/fiber";
import { useControls } from "leva";
import anime from "animejs/lib/anime.es.js";

import { lerp } from "../../helpers/animation";
import useStore from "../../store";

export default function Model({ ...props }) {
  /** GLTF PaperPlane controls leva */
  const {
    scaleFactor,
    color,
    positionX,
    positionY,
    positionZ,
    wireframe,
    rotationX,
    rotationY,
    rotationZ,
    emissiveIntensity,
  } = useControls("plane", {
    scaleFactor: {
      value: 10,
      min: 0.1,
      max: 100,
      step: 0.5,
    },
    emissiveIntensity: {
      min: 0,
      max: 100,
      value: 0,
      step: 0.01,
    },
    color: "#fff",
    positionX: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.01,
    },
    positionY: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    positionZ: {
      value: 695,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    rotationX: {
      value: Math.PI / 2,
      step: 0.1,
      min: -1000,
      max: 1000,
    },
    rotationY: {
      value: 0,
      step: 0.1,
      min: -1000,
      max: 1000,
    },
    rotationZ: {
      value: -Math.PI * 2,
      step: 0.001,
      min: -1000,
      max: 1000,
    },
    wireframe: false,
  });

  /** GLTF variables */
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/ekzotik.glb");
  const { actions } = useAnimations(animations, group);

  /** GLTF PaperPlane textures */
  const test = useLoader(THREE.TextureLoader, "/test.jpg");
  const hello = useLoader(THREE.TextureLoader, "/hello.jpeg");
  hello.flipY = false;
  test.flipY = false;

  /** Window event listener handlers */
  const divContainer = document.getElementById("fold");
  var maxHeight = divContainer.clientHeight - window.innerHeight;
  var percentage = 0;
  var scrollY = 0;
  var event = {
    y: 0,
    deltaY: 0,
  };

  let time = 0;

  function onWheel(e) {
    var evt = event;
    evt.deltaY = e.wheelDeltaY || e.deltaY * -1;
    // reduce by half the delta amount otherwise it scroll too fast
    evt.deltaY *= 0.5;

    scroll(e);
  }
  function scroll(e) {
    var evt = event;
    // limit scroll top
    if (evt.y + evt.deltaY > 0) {
      evt.y = 0;
      // limit scroll bottom
    } else if (-(evt.y + evt.deltaY) >= maxHeight) {
      evt.y = -maxHeight;
    } else {
      evt.y += evt.deltaY;
    }
    scrollY = -evt.y;
    percentage = lerp(percentage, scrollY, 0.07);
    if (percentage >= 0 && percentage < 15000) {
      actions?.fold?._mixer.setTime(percentage * (15000 / maxHeight));
    } else {
      if (percentage >= 15000) {
        time = percentage - 15000;

        console.log("TIME", time);
        // timeline.seek(time);
      }
    }
  }
  const onResize = () => {
    maxHeight =
      (divContainer.clientHeight || divContainer.offsetHeight) -
      window.innerHeight;
  };

  /** Store subscription handling */
  const positionRef = useRef([0, 0, 695]);

  useEffect(() => {
    //Scroll & resize event listeners
    divContainer.scrollIntoView();
    divContainer.addEventListener("wheel", onWheel, false);
    window.addEventListener("resize", onResize, { passive: true });

    //GLTF animation
    const { fold } = actions;
    fold.clampWhenFinished = true;
    fold.repetitions = 1;
    fold.setDuration(15000);
    fold.play();

    //Zustand store subscriptions
    const unsubscribePosition = useStore.subscribe(
      (state) => state.paperPlane,
      ({ position }) => {
        positionRef.current = position;
        group.current && group.current.position.set(...positionRef.current);
      }
    );

    const unsubscribeRotation = useStore.subscribe(
      (state) => state.paperPlane,
      ({ axis, angle }) => {
        console.log("AXIS", axis);
        console.log("ANGLE", angle);
        if (axis != null && angle != null) {
          group.current &&
            group.current.quaternion.setFromAxisAngle(axis, angle);
        }
      }
    );

    //Remove event listeners and subscriptions
    return () => {
      divContainer.removeEventListener("wheel", onWheel);
      window.removeEventListener("resize", onResize);
      unsubscribePosition();
      unsubscribeRotation();
    };
  }, []);

  /** Anime JS timeline */
  const [timeline] = useState(() =>
    anime.timeline({
      autoplay: false,
      duration: 1000,
    })
  );

  useEffect(() => {
    if (group.current) {
      timeline.add({
        targets: group.current.rotation,
        x: 0.6,
        y: 0,
        z: 0,
        duration: 1000,
      });
    }
  }, [group.current]);

  return (
    <group
      scale={[scaleFactor, scaleFactor, scaleFactor]}
      rotation={[rotationX, rotationY, rotationZ]}
      position={positionRef.current}
      ref={group}
      {...props}
      dispose={null}
    >
      <mesh
        layers={2}
        name="Plane_1"
        geometry={nodes.Plane_1.geometry}
        material={materials.back}
        morphTargetDictionary={nodes.Plane_1.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane_1.morphTargetInfluences}
      ></mesh>
      <mesh
        layers={2}
        name="Plane_2"
        geometry={nodes.Plane_2.geometry}
        material={materials.side}
        morphTargetDictionary={nodes.Plane_2.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane_2.morphTargetInfluences}
      >
        <meshStandardMaterial color={"#fff"} />
      </mesh>
      <mesh
        layers={2}
        name="Plane_3"
        geometry={nodes.Plane_3.geometry}
        material={materials.front}
        morphTargetDictionary={nodes.Plane_3.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane_3.morphTargetInfluences}
      >
        <meshStandardMaterial color={"#fff"} />
      </mesh>
    </group>
  );
}

useGLTF.preload("/ekzotik.glb");
