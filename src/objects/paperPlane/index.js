/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useCallback } from "react";
import * as THREE from "three";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useControls } from "leva";
import { useFrame, useThree } from "@react-three/fiber";
import react from "react";

export default react.forwardRef(({ timeline, ...props }, plane) => {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/plane.glb");
  const { actions } = useAnimations(animations, group);
  const { camera } = useThree();

  /**
   * Plane controls
   */

  const {
    scaleFactor,
    color,
    positionX,
    positionY,
    positionZ,
    wireframe,
    rotationX,
    rotationY,
    rotationZ,
  } = useControls("plane", {
    scaleFactor: {
      value: 8,
      min: 0.1,
      max: 100,
      step: 0.5,
    },
    color: "#006f6f",
    positionX: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.01,
    },
    positionY: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    positionZ: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    rotationX: {
      value: Math.PI / 2,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    rotationY: {
      value: 0,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    rotationZ: {
      value: Math.PI,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    wireframe: false,
  });

  const visibleHeightAtZDepth = (depth, camera) => {
    // compensate for cameras not positioned at z=0
    const cameraOffset = camera.position.z;
    if (depth < cameraOffset) depth -= cameraOffset;
    else depth += cameraOffset;

    // vertical fov in radians
    const vFOV = (camera.fov * Math.PI) / 180;

    // Math.abs to ensure the result is always positive
    return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
  };

  const visibleWidthAtZDepth = (depth, camera) => {
    const height = visibleHeightAtZDepth(depth, camera);
    return height * camera.aspect;
  };

  useEffect(() => {
    if (plane.current !== null) {
      plane.current.rotation.x = Math.PI / 2;
      plane.current.position.x = -(visibleWidthAtZDepth(0, camera) / 2) + 100;
      plane.current.position.y = -(visibleHeightAtZDepth(0, camera) / 4);
    }
    const { fold } = actions;
    fold.repetitions = 1;
    fold.clampWhenFinished = true;
    // fold.setDuration(3);
    // fold.play();
  }, [plane.current]);

  useEffect(() => console.log("PLANE RE RENDERED"));

  return (
    <group ref={group} {...props} dispose={null}>
      <mesh
        layers={2}
        scale={[scaleFactor, scaleFactor, scaleFactor]}
        rotation={[rotationX, rotationY, rotationZ]}
        ref={plane}
        name="Plane"
        geometry={nodes.Plane.geometry}
        material={materials.Material}
        rotation={[rotationX, rotationY, rotationZ]}
        morphTargetDictionary={nodes.Plane.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane.morphTargetInfluences}
        receiveShadow={true}
      >
        <meshStandardMaterial
          {...materials.Material}
          side={THREE.DoubleSide}
          wireframe={wireframe}
          shadowSide={THREE.DoubleSide}
          color={color}
          emissiveIntensity={0.1}
          emissive={color}
        ></meshStandardMaterial>
      </mesh>
    </group>
  );
});
useGLTF.preload("/plane.glb");
