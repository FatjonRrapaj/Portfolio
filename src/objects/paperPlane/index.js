/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { forwardRef, useEffect, useRef } from "react";
import * as THREE from "three";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useControls } from "leva";
import { useFrame, useThree } from "@react-three/fiber";

export default forwardRef(({ ...props }, plane) => {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/plane.glb");
  const { actions } = useAnimations(animations, group);
  const { camera } = useThree();
  console.log("CAM", camera);

  /**
   * Plane controls
   */

  const {
    scaleFactor,
    color,
    positionX,
    positionY,
    positionZ,
    wireframe,
    rotationX,
    rotationY,
    rotationZ,
  } = useControls("plane", {
    scaleFactor: {
      value: 3,
      min: 0.1,
      max: 100,
      step: 0.5,
    },
    color: "#6200ff",
    positionX: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.01,
    },
    positionY: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    positionZ: {
      value: 0,
      min: -1000,
      max: 1000,
      step: 0.1,
    },
    rotationX: {
      value: Math.PI / 2,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    rotationY: {
      value: 0,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    rotationZ: {
      value: Math.PI,
      step: Math.PI / 10,
      min: -1000,
      max: 1000,
    },
    wireframe: false,
  });

  const visibleHeightAtZDepth = (depth, camera) => {
    // compensate for cameras not positioned at z=0
    const cameraOffset = camera.position.z;
    if (depth < cameraOffset) depth -= cameraOffset;
    else depth += cameraOffset;

    // vertical fov in radians
    const vFOV = (camera.fov * Math.PI) / 180;

    // Math.abs to ensure the result is always positive
    return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
  };

  const visibleWidthAtZDepth = (depth, camera) => {
    const height = visibleHeightAtZDepth(depth, camera);
    return height * camera.aspect;
  };

  useEffect(() => {
    const { fold } = actions;
    plane.current && plane.current.quaternion.copy(camera.quaternion);
    fold.repetitions = 1;
    fold.clampWhenFinished = true;
    if (plane.current) {
      plane.current.rotation.x = Math.PI / 2;
      console.log("Pl CURRENT", plane.current);
      plane.current.position.x = -(visibleWidthAtZDepth(0, camera) / 2) + 34;
      plane.current.position.y = -(visibleHeightAtZDepth(0, camera) / 4);
    }
    setTimeout(() => {
      // fold.play();
    }, 2000);
  }, [plane]);

  // useEffect(() => {
  //   if (plane.current) {
  //     console.log("ENTERED HERRRE");
  //     const raycaster = new THREE.Raycaster();
  //     const corner = new THREE.Vector2();
  //     const cornerPoint = new THREE.Vector3();
  //     corner.set(0, 0); // NDC of the bottom-left corner
  //     raycaster.setFromCamera(corner, camera);

  //     plane.current.position.copy(cornerPoint).add(new THREE.Vector3(1, 1, -1)); // align the position of the box
  //   }
  // }, [plane]);

  return (
    <group ref={group} {...props} dispose={null}>
      <mesh
        layers={2}
        scale={[scaleFactor, scaleFactor, scaleFactor]}
        rotation={[rotationX, rotationY, rotationZ]}
        ref={plane}
        name="Plane"
        position={[-1000, positionY, positionZ]}
        geometry={nodes.Plane.geometry}
        material={materials.Material}
        rotation={[rotationX, rotationY, rotationZ]}
        morphTargetDictionary={nodes.Plane.morphTargetDictionary}
        morphTargetInfluences={nodes.Plane.morphTargetInfluences}
        receiveShadow={true}
      >
        <meshStandardMaterial
          {...materials.Material}
          side={THREE.DoubleSide}
          wireframe={wireframe}
          shadowSide={THREE.DoubleSide}
          color={color}
          emissiveIntensity={0.1}
          emissive={color}
        ></meshStandardMaterial>
      </mesh>
    </group>
  );
});

useGLTF.preload("/plane.glb");
